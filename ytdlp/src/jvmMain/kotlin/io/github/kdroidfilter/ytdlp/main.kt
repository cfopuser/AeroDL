import io.github.kdroidfilter.ytdlp.YtDlpWrapper
import io.github.kdroidfilter.ytdlp.YtDlpWrapper.InitEvent
import io.github.kdroidfilter.ytdlp.core.Event
import io.github.kdroidfilter.ytdlp.getPlaylistInfo
import io.github.kdroidfilter.ytdlp.getVideoInfo
import kotlinx.coroutines.runBlocking
import java.io.File
import java.time.Duration

fun main() = runBlocking {
    val wrapper = YtDlpWrapper().apply {
        downloadDir = File(System.getProperty("user.home"), "Downloads/yt-dlp")
    }

    // Initialisation
    println("üîß Initialisation de yt-dlp/ffmpeg‚Ä¶")
    val initOk = wrapper.initialize { ev ->
        when (ev) {
            is InitEvent.CheckingYtDlp -> println("üîç V√©rification de yt-dlp‚Ä¶")
            is InitEvent.DownloadingYtDlp -> println("‚¨áÔ∏è T√©l√©chargement de yt-dlp‚Ä¶")
            is InitEvent.UpdatingYtDlp -> println("‚¨ÜÔ∏è Mise √† jour de yt-dlp‚Ä¶")
            is InitEvent.EnsuringFfmpeg -> println("üé¨ V√©rification de FFmpeg‚Ä¶")
            is InitEvent.YtDlpProgress -> {
                val pct = ev.percent?.let { String.format("%.1f", it) } ?: "?"
                print("\r‚¨áÔ∏è yt-dlp: $pct%")
            }
            is InitEvent.FfmpegProgress -> {
                val pct = ev.percent?.let { String.format("%.1f", it) } ?: "?"
                print("\rüé¨ FFmpeg: $pct%")
            }
            is InitEvent.Error -> {
                println("\n‚ö†Ô∏è Init: ${ev.message}")
                ev.cause?.let { println("   ‚Ü≥ ${it::class.simpleName}: ${it.message}") }
            }
            is InitEvent.Completed -> println(if (ev.success) "\n‚úÖ Init ok" else "\n‚ùå Init √©chou√©e")
        }
    }

    if (!initOk) {
        println("Arr√™t car initialisation impossible.")
        return@runBlocking
    }

    println("‚úÖ yt-dlp version: ${wrapper.version() ?: "inconnue"}")
    println("‚úÖ FFmpeg: ${wrapper.ffmpegPath ?: "(via PATH ou gestion interne)"}")
    println("üìÅ Download dir: ${wrapper.downloadDir?.absolutePath}")

    // Essayons plusieurs URLs pour tester
    val urls = listOf(
        "https://www.youtube.com/watch?v=0Hv5LTxAutw",
        "https://www.youtube.com/watch?v=UoywDs3YXOM"
    )

    for (url in urls) {
        println("\nüé¨ Tentative avec: $url")

        wrapper.getVideoInfo(url, noCheckCertificate = true, timeoutSec = 30)
            .onSuccess { video ->
                println("‚úÖ Succ√®s!")
                println("  üìù Titre: ${video.title}")
                println("  ‚è±Ô∏è Dur√©e: ${video.duration}")
                println("  üñºÔ∏è Thumbnail: ${video.thumbnail}")
                println("  üë§ Uploader: ${video.uploader}")
                println("  üìÖ Date: ${video.uploadDate}")
                println("  üëÅÔ∏è Vues: ${video.viewCount}")

                if (video.availableSubtitles.isNotEmpty()) {
                    println("  üìÑ Sous-titres disponibles:")
                    video.availableSubtitles.forEach { (lang, info) ->
                        println("    - $lang: ${info.languageName ?: lang} ${if (info.autoGenerated) "(auto)" else ""}")
                    }
                }
            }
            .onFailure { error ->
                println("‚ùå √âchec: ${error.message}")
                error.printStackTrace()

                // Essayons de lancer yt-dlp directement pour voir le probl√®me
                println("\nüîç Test direct de yt-dlp avec l'URL:")
                try {
                    val testCmd = listOf(
                        wrapper.ytDlpPath,
                        "--dump-json",
                        "--no-playlist",
                        "--no-check-certificate",
                        url
                    )
                    println("  Commande: ${testCmd.joinToString(" ")}")

                    val process = ProcessBuilder(testCmd)
                        .redirectErrorStream(false)
                        .start()

                    val stdout = process.inputStream.bufferedReader().readText()
                    val stderr = process.errorStream.bufferedReader().readText()
                    val exitCode = process.waitFor()

                    println("  Exit code: $exitCode")
                    if (stderr.isNotBlank()) {
                        println("  Stderr (erreurs):")
                        stderr.lines().take(20).forEach { println("    $it") }
                    }
                    if (stdout.isNotBlank()) {
                        println("  Stdout (tronqu√© √† 500 chars):")
                        println("    ${stdout.take(500)}")
                    }
                } catch (e: Exception) {
                    println("  Erreur lors du test direct: ${e.message}")
                }
            }
    }

    wrapper.getPlaylistInfo(
        url = "https://www.youtube.com/watch?v=TmpCU_7hP_s&list=PLQkwcJG4YTCQ3V9U0aJOfhgjeKVuznat0",
        noCheckCertificate = true
    ).onSuccess {
        println(it.title)
    }.onFailure {
        println(it.message)
    }

    // Test de la connectivit√© r√©seau vers YouTube
    println("\nüåê Test de connectivit√© r√©seau:")
    wrapper.checkNetwork("https://www.youtube.com", 5000, 5000)
        .onSuccess { println("  ‚úÖ Connexion √† YouTube OK") }
        .onFailure { println("  ‚ùå Probl√®me r√©seau: ${it.message}") }
}